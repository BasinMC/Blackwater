package org.basinmc.blackwater.task.git;

import edu.umd.cs.findbugs.annotations.NonNull;
import edu.umd.cs.findbugs.annotations.Nullable;
import java.io.IOException;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.PathMatcher;
import java.nio.file.Paths;
import java.util.Iterator;
import java.util.Set;
import java.util.regex.Pattern;
import org.basinmc.blackwater.artifact.ArtifactManager;
import org.basinmc.blackwater.artifact.ArtifactReference;
import org.basinmc.blackwater.task.AbstractCommandExecutorTask;
import org.basinmc.blackwater.task.AbstractConfigurableTask;
import org.basinmc.blackwater.task.Task;
import org.basinmc.blackwater.task.error.TaskExecutionException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Applies a git mail archive to an arbitrary repository.
 *
 * @author <a href="mailto:johannesd@torchmind.com">Johannes Donath</a>
 */
public final class GitPatchTask extends AbstractCommandExecutorTask {

  /**
   * Defines a file matcher which matches the patch files generated by git's mail archive command.
   */
  private static final PathMatcher PATCH_FILE_MATCHER = FileSystems.getDefault()
      .getPathMatcher("regex:^\\d{4,}\\-[\\w._-]+\\.patch$");
  /**
   * Defines a regex pattern which matches the patch number.
   */
  private static final Pattern PATCH_NUMBER_MATCHER = Pattern.compile("^(\\d{4,})\\-");
  private static final Logger logger = LoggerFactory.getLogger(GitPatchTask.class);
  private final Path patchDirectory;
  private final Path repository;
  private final String resetBranch;

  private GitPatchTask(
      @NonNull Path patchDirectory,
      @NonNull Path repository,
      @Nullable String resetBranch,
      @NonNull Set<Class<? extends Task>> optionalTasks,
      @NonNull Set<ArtifactReference> requiredArtifacts,
      @NonNull Set<Class<? extends Task>> requiredTasks) {
    super(optionalTasks, requiredArtifacts, requiredTasks);
    this.patchDirectory = patchDirectory;
    this.resetBranch = resetBranch;
    this.repository = repository;
  }

  /**
   * Creates a new factory for this task implementation.
   *
   * @return a builder.
   */
  @NonNull
  public static Builder builder() {
    return new Builder();
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public void execute(@NonNull Context context) throws TaskExecutionException {
    // if the directory we were given does not exist, we'll skip the execution immediately as there
    // is nothing for us to do (we do not consider this an error case logically as it is equal to
    // not having any source code to compile)
    if (Files.notExists(this.patchDirectory)) {
      return;
    }

    // since we need the repository to be in a clean state, we'll force git to abort any pending
    // merges before we're doing anything else here
    try {
      this.executeCommand(this.repository, "git", "am", "--abort");

      if (this.resetBranch != null) {
        this.executeCommand(this.repository, "git", "reset", "--hard", this.resetBranch);
      }
    } catch (InterruptedException ex) {
      throw new TaskExecutionException(
          "Interrupted while awaiting completion of git command: " + ex.getMessage(), ex);
    } catch (IOException ex) {
      throw new TaskExecutionException("Failed to invoke git: " + ex.getMessage(), ex);
    }

    // otherwise we'll loop over every single of the patch files within the directory and apply them
    // to the git repository (provided that git does not fail at any point during this process)
    try {
      Iterator<Path> it = Files.list(this.patchDirectory)
          .filter(PATCH_FILE_MATCHER::matches)
          .sorted((p1, p2) -> {
            int number1 = Integer.parseUnsignedInt(
                PATCH_NUMBER_MATCHER.matcher(p1.getFileName().toString()).group(1));
            int number2 = Integer.parseUnsignedInt(
                PATCH_NUMBER_MATCHER.matcher(p2.getFileName().toString()).group(1));

            return Math.min(1, Math.max(-1, number1 - number2));
          })
          .iterator();

      while (it.hasNext()) {
        Path next = it.next();

        logger.info("    Applying {}", next.getFileName());

        try {
          this.executeCommand(this.repository, "git", "am", "--ignore-whitespace",
              "--3way",
              this.repository.relativize(next.toAbsolutePath()).toString());
        } catch (InterruptedException ex) {
          throw new TaskExecutionException(
              "Interrupted while awaiting completion of git command: " + ex.getMessage(), ex);
        } catch (IOException ex) {
          throw new TaskExecutionException("Failed to invoke git: " + ex.getMessage(), ex);
        }
      }
    } catch (IOException ex) {
      throw new TaskExecutionException("Failed to access patch directory: " + ex.getMessage(), ex);
    }

    logger.info("Patching completed");
  }

  /**
   * {@inheritDoc}
   */
  @NonNull
  @Override
  public String getName() {
    return "git-am";
  }

  /**
   * Provides a factory for git patch task instances.
   */
  public static final class Builder extends AbstractConfigurableTask.Builder<GitPatchTask> {

    private Path patchDirectory;
    private Path repository = Paths.get(".");
    private String resetBranch;

    private Builder() {
    }

    /**
     * Constructs a new git patch task using the builder's configuration.
     *
     * @return a new task instance.
     * @throws IllegalStateException when no repository directory has been set.
     */
    @NonNull
    public GitPatchTask build() {
      if (this.patchDirectory == null) {
        throw new IllegalStateException("Illegal task configuration: Patch directory is required");
      }

      return new GitPatchTask(
          this.patchDirectory,
          this.repository,
          this.resetBranch,
          this.optionalTasks,
          this.requiredArtifacts,
          this.requiredTasks
      );
    }

    /**
     * {@inheritDoc}
     */
    @NonNull
    @Override
    public GitPatchTask build(@NonNull ArtifactManager manager) {
      return this.build();
    }

    /**
     * {@inheritDoc}
     */
    @NonNull
    @Override
    public Builder withOptionalTask(@NonNull Class<? extends Task> task) {
      super.withOptionalTask(task);
      return this;
    }

    /**
     * Selects a directory to retrieve patches from.
     *
     * @param directory a directory reference.
     * @return a reference to this builder.
     */
    @NonNull
    public Builder withPatchDirectory(@NonNull Path directory) {
      this.patchDirectory = directory;
      return this;
    }

    /**
     * Selects a repository to execute the task in.
     *
     * @param repository a repository path.
     * @return a reference to this builder.
     */
    @NonNull
    public Builder withRepository(@NonNull Path repository) {
      this.repository = repository;
      return this;
    }

    /**
     * {@inheritDoc}
     */
    @NonNull
    @Override
    public Builder withRequiredArtifact(@NonNull ArtifactReference reference) {
      super.withRequiredArtifact(reference);
      return this;
    }

    /**
     * {@inheritDoc}
     */
    @NonNull
    @Override
    public Builder withRequiredTask(@NonNull Class<? extends Task> task) {
      super.withRequiredTask(task);
      return this;
    }

    /**
     * Selects the branch to reset to before applying a set of patches.
     *
     * @param branch a branch (or null if none is desired).
     * @return a reference to this builder.
     */
    @NonNull
    public Builder withResetBranch(@Nullable String branch) {
      this.resetBranch = branch;
      return this;
    }
  }
}
