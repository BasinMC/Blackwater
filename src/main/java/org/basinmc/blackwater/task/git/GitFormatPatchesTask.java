package org.basinmc.blackwater.task.git;

import edu.umd.cs.findbugs.annotations.NonNull;
import java.io.IOException;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.PathMatcher;
import java.nio.file.Paths;
import java.util.Iterator;
import java.util.Set;
import org.basinmc.blackwater.artifact.ArtifactManager;
import org.basinmc.blackwater.artifact.ArtifactReference;
import org.basinmc.blackwater.task.AbstractCommandExecutorTask;
import org.basinmc.blackwater.task.AbstractConfigurableTask;
import org.basinmc.blackwater.task.Task;
import org.basinmc.blackwater.task.error.TaskExecutionException;
import org.eclipse.jgit.api.Git;
import org.eclipse.jgit.api.Status;
import org.eclipse.jgit.api.errors.GitAPIException;
import org.eclipse.jgit.internal.storage.file.FileRepository;
import org.eclipse.jgit.lib.Repository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * (Re-)Generates a git mail archive based on the commits in a repository and its respective
 * reference branch.
 *
 * @author <a href="mailto:johannesd@torchmind.com">Johannes Donath</a>
 */
public class GitFormatPatchesTask extends AbstractCommandExecutorTask {

  /**
   * Defines a file matcher which matches the patch files generated by git's mail archive command.
   */
  private static final PathMatcher PATCH_FILE_MATCHER = FileSystems.getDefault()
      .getPathMatcher("regex:^\\d{4,}\\-[\\w._-]+\\.patch$");
  private static final Logger logger = LoggerFactory.getLogger(GitFormatPatchesTask.class);
  private final Path patchDirectory;
  private final String referenceBranch;
  private final Path repository;

  private GitFormatPatchesTask(
      @NonNull Path patchDirectory,
      @NonNull Path repository,
      @NonNull String referenceBranch,
      @NonNull Set<Class<? extends Task>> optionalTasks,
      @NonNull Set<ArtifactReference> requiredArtifacts,
      @NonNull Set<Class<? extends Task>> requiredTasks) {
    super(optionalTasks, requiredArtifacts, requiredTasks);
    this.patchDirectory = patchDirectory;
    this.repository = repository;
    this.referenceBranch = referenceBranch;
  }

  /**
   * Creates a new empty generate patches factory.
   *
   * @return a builder.
   */
  @NonNull
  public static Builder builder() {
    return new Builder();
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public void execute(@NonNull Context context) throws TaskExecutionException {
    // before we re-generate our patches to the target directory, we'll delete all existing patch
    // files to ensure that we don't end up with conflicting files (rebasing may cause the order of
    // patches to shift or patches to completely disappear from the repository)
    try {
      Iterator<Path> it = Files.list(this.patchDirectory)
          .filter(PATCH_FILE_MATCHER::matches)
          .iterator();

      while (it.hasNext()) {
        Files.delete(it.next());
      }
    } catch (IOException ex) {
      throw new TaskExecutionException("Failed to delete patch file: " + ex.getMessage(), ex);
    }

    // since we have jgit on our path anyways, we may as well verify the state in which our
    // repository is at the moment in order to warn the developer when they are generating an
    // incomplete set of patches due to the repository state
    try (Repository repository = new FileRepository(this.repository.toFile())) {
      try (Git git = new Git(repository)) {
        Status status = git.status().call();

        if (!status.isClean()) {
          logger.warn("Source repository is in an unclean state");
          logger.warn("Unstaged changes will be omitted in generated patch set");
        }
      }
    } catch (GitAPIException ex) {
      throw new TaskExecutionException("Failed to retrieve git status: " + ex.getMessage(), ex);
    } catch (IOException ex) {
      throw new TaskExecutionException("Failed to access git repository: " + ex.getMessage(), ex);
    }

    // at this point we may simply generate a set of patches based on the specified reference
    // branch
    try {
      this.executeCommand(
          this.repository,
          "git",
          "--minimal", // spend extra time to create the smallest patches possible
          "--no-stat", // No diffstats
          "--no-numbered", // Number Format
          "--output-directory",
          this.repository.relativize(this.repository.toAbsolutePath()).toString(),
          this.referenceBranch
      );
    } catch (InterruptedException ex) {
      throw new TaskExecutionException(
          "Interrupted while awaiting git command completion: " + ex.getMessage(), ex);
    } catch (IOException ex) {
      throw new TaskExecutionException("Failed to invoke git command: " + ex.getMessage(), ex);
    }
  }

  /**
   * Provides a factory for git generate-patches tasks.
   */
  public static final class Builder extends AbstractConfigurableTask.Builder<GitFormatPatchesTask> {

    private Path patchDirectory;
    private String referenceBranch = "upstream";
    private Path repository = Paths.get(".");

    /**
     * Creates a new git generate patches task using this builder's current configuration.
     *
     * @return a generate patches task.
     */
    @NonNull
    public GitFormatPatchesTask build() {
      if (this.patchDirectory == null) {
        throw new IllegalStateException("Illegal task configuration: Patch directory is required");
      }

      return new GitFormatPatchesTask(
          this.patchDirectory,
          this.repository,
          this.referenceBranch,
          this.optionalTasks,
          this.requiredArtifacts,
          this.requiredTasks
      );
    }

    /**
     * {@inheritDoc}
     */
    @NonNull
    @Override
    public GitFormatPatchesTask build(@NonNull ArtifactManager manager) {
      return this.build();
    }

    /**
     * {@inheritDoc}
     */
    @NonNull
    @Override
    public Builder withOptionalTask(
        @NonNull Class<? extends Task> task) {
      super.withOptionalTask(task);
      return this;
    }

    /**
     * {@inheritDoc}
     */
    @NonNull
    @Override
    public Builder withRequiredArtifact(
        @NonNull ArtifactReference reference) {
      super.withRequiredArtifact(reference);
      return this;
    }

    /**
     * {@inheritDoc}
     */
    @NonNull
    @Override
    public Builder withRequiredTask(
        @NonNull Class<? extends Task> task) {
      super.withRequiredTask(task);
      return this;
    }
  }
}
